<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Dom De Re" />
  <title>Adjoint Functors</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
    </style>
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
  <link rel="stylesheet" media="print" href="reveal.js/css/print/pdf.css" />
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Adjoint Functors</h1>
    <h2 class="author">Dom De Re</h2>
    <h3 class="date">21 October, 2015</h3>
</section>

<section><section id="motivation" class="titleslide slide level1"><h1>Motivation</h1></section><section id="isomorphisms" class="slide level2">
<h1>Isomorphisms</h1>
<p>Awesome.</p>
<ul>
<li>Learn about <code>X</code></li>
<li>Learn about <code>Y</code></li>
<li>Feel a little bit of deja vu.</li>
<li>Learn you wasted time learning the same thing twice.</li>
<li>Mind blown though.</li>
</ul>
</section><section id="not-quite-isomorphic" class="slide level2">
<h1>Not quite Isomorphic</h1>
<ul>
<li>A lot of things are &quot;similar&quot;, two things may not be directly isomorphic but still feel like they have some notion of similarity</li>
<li>Mathematicians try to find some isomorphism somewhere to put a <em>concrete</em> finger on the nose of the vague notion of similarity</li>
</ul>
</section><section id="comonads-how-do-they-work" class="slide level2">
<h1>(Co)monads, how do they work?</h1>
<ul>
<li>Explanations and tutorials often involve vague handwavy words like &quot;context&quot; and &quot;burrito&quot;, but dont adequately describe what these things mean.</li>
<li>What are the internal mechanics of <code>return</code>, <code>join</code>, <code>duplicate</code>, and are they related?</li>
<li>The monad laws are enough to <em>use</em> and <em>write</em> monads, but sometimes its nice to know the science behind the tools and learn the deeper truths</li>
</ul>
</section><section id="comonads-where-the-hell-are-they" class="slide level2">
<h1>Comonads, where the hell are they?</h1>
<ul>
<li>Once heard someone say &quot;monads are not a snowflake&quot; and that they could also have been the dominant mechanism in FP.</li>
<li>Yet the monad path was more popular, and generally there are a lot more monads around, why?</li>
</ul>
</section><section id="how-do-you-compose-monads" class="slide level2">
<h1>How do you compose monads?</h1>
<blockquote>
<p>Monads generally do not compose.</p>
</blockquote>
<p>This is a statement beginners here a lot, and its tricky to really make sense of, after all what does it mean to compose monads?</p>
</section><section id="option-1" class="slide level2">
<h1>Option 1</h1>
<p>If <code>m</code> is a monad and <code>n</code> is a monad, then is <code>newtype F a = F (m (n a)) a</code> monad?</p>
</section><section id="option-2" class="slide level2">
<h1>Option 2</h1>
<p>If <code>m</code> is a monad and <code>n</code> is a monad, is there a way I can structurally decompose <code>m</code> and embed <code>n</code> in a composable manner?</p>
</section><section id="compose-like-traversals" class="slide level2">
<h1>Compose like traversals?</h1>
<blockquote>
<p>Traversals compose, so does that mean traversable monads compose?</p>
</blockquote>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Traversal</span> s t a b <span class="fu">=</span> forall f s t a b<span class="fu">.</span> (<span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t</code></pre>
<ul>
<li>Traversals in this form of compose functionally (option 1)</li>
<li>Functionally composing traversals (option 1) are equivalent to structurally embedding one traversal in another (option 2)</li>
<li>So the statement &quot;traversals compose&quot; is easy to make sense of because the two cases collapse into the same thing.</li>
</ul>
</section><section id="do-monads-compose" class="slide level2">
<h1>Do monads compose?</h1>
<ul>
<li>Option 1: generally no.</li>
<li>Option 2: (generally?) yes.</li>
</ul>
</section><section id="problems-and-solutions" class="slide level2">
<h1>Problems and Solutions</h1>
<p>The problem of finding or constructing representations with certain properties is something that preoccupies programmers and mathematicians alike.</p>
<ul>
<li>How do they present the problem?</li>
<li>How do they determine what qualifies
<ul>
<li>as an &quot;efficient&quot; solution?</li>
<li>as a &quot;formulaic&quot; solution?</li>
</ul></li>
</ul>
</section></section>
<section><section id="definitions" class="titleslide slide level1"><h1>Definitions</h1></section><section id="quickly" class="slide level2">
<h1>Quickly</h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Category_(mathematics)">Categories</a></li>
<li><a href="https://en.wikipedia.org/wiki/Initial_and_terminal_objects">Initial and Final objects</a></li>
<li><a href="https://en.wikipedia.org/wiki/Functor">Functors</a></li>
<li><a href="https://en.wikipedia.org/wiki/Natural_transformation">Naturality</a></li>
</ul>
</section><section id="universal-properties" class="slide level2">
<h1>Universal Properties</h1>
<ul>
<li><p>A <em>universal property</em> defines what it means for a construction to be the &quot;most efficient&quot; solution to a problem.</p></li>
<li>Comes in two flavours:
<ul>
<li>Initial Properties</li>
<li>Terminal properties</li>
</ul></li>
<li><p>They are dual, so usually only discussion of one is necessary, just reverse the arrows for the other.</p></li>
</ul>
</section><section id="initial-property" class="slide level2">
<h1>Initial Property</h1>
<p><code>C, D</code> categories, <code>U: D -&gt; C</code> , let <code>X ∈ Obj(C)</code></p>
<p>An <em>initial morphism</em> is a pair <code>(A, φ)</code> where <code>A ∈ Obj(D)</code> and <code>φ: X -&gt; U(A)</code> then <code>∀Y ∈ Obj(D)</code> and <code>f: X -&gt; U(Y)</code>, there exists a <strong>unique</strong> <code>g: A -&gt; Y</code> such that the following diagram commutes:</p>
</section><section class="slide level2">

<figure>
<img src="./assets/universal-prop.png" alt="An initial property" /><figcaption>An initial property</figcaption>
</figure>
</section><section id="examples" class="slide level2">
<h1>Examples</h1>
</section><section id="coproducts" class="slide level2">
<h1>Coproducts</h1>
<figure>
<img src="./assets/coproduct-initial-property.png" alt="The initial property for products" /><figcaption>The initial property for products</figcaption>
</figure>
</section><section id="products" class="slide level2">
<h1>Products</h1>
<figure>
<img src="./assets/product-terminal-property.png" alt="The terminal property for products" /><figcaption>The terminal property for products</figcaption>
</figure>
</section><section id="efficiency" class="slide level2">
<h1>Efficiency</h1>
<p>What makes <code>(A, φ)</code> so efficient?</p>
<ul>
<li>The fact that <code>g</code> exists at all implies that <code>(A, φ)</code> is general enough for all <code>(Y, f)</code>.</li>
<li>The fact that <code>g</code> is unique implies that <code>(A, φ)</code> is not too general</li>
</ul>
<p>The existence and uniqueness mean that <code>f</code> <strong>uniquely factorises</strong> like so: <code>f = U(g).φ</code>, so rather than analyse <code>f: X -&gt; U(Y)</code>, we can look at <code>g: A -&gt; Y</code> which could be a lot simpler.</p>
</section><section id="adjunctions" class="slide level2">
<h1>Adjunctions</h1>
<ul>
<li><p>An efficient solution is great, whats even <strong>better</strong> is if it is <em>formulaic</em>, i.e for <em>every</em> <code>X</code> in the diagram, I can construct an <code>(A = F(X), φ)</code>.</p></li>
<li><p>Then my solution is not only <em>efficient</em>, I can also spray it indiscriminately over my problem domain.</p></li>
</ul>
</section><section class="slide level2">

<p>For <code>F: D -&gt; C</code> and <code>G: C -&gt; D</code> functors between locally small categories <code>C</code> and <code>D</code></p>
<p><code>F</code> and <code>G</code> are said to be <em>adjoint</em> with <code>F</code> <em>left adjoint</em> to <code>G</code> and <code>G</code> <em>right adjoint</em> to <code>F</code> iff there is a bijection <code>ϕ</code>, natural in <code>X</code> and <code>Y</code>, any <code>X ∈ Obj(C)</code>, any <code>Y ∈ Obj(D)</code>:</p>
<figure>
<img src="./assets/adjunction-bijection.png" />
</figure>
</section><section class="slide level2">

<figure>
<img src="./assets/adjunction-naturality.png" alt="The naturality of ϕ" /><figcaption>The naturality of ϕ</figcaption>
</figure>
</section><section class="slide level2">

<p>The naturality of ϕ</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">k<span class="fu">:</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">X&#39;</span>
h<span class="fu">:</span> <span class="dt">Y</span> <span class="ot">-&gt;</span> <span class="dt">Y&#39;</span>

ϕ(k<span class="fu">.</span>f)  <span class="fu">=</span> <span class="dt">Gk</span><span class="fu">.</span>ϕ(f)
ϕ(f<span class="fu">.</span><span class="dt">Fh</span>) <span class="fu">=</span> ϕ(f)<span class="fu">.</span>h</code></pre>
</section></section>
<section><section id="monads" class="titleslide slide level1"><h1>Monads</h1></section><section class="slide level2">

<p>The adjunction holds <code>∀X ∈ Obj(C)</code> and <code>FY ∈ Obj(C)</code>, so what do we get if we substitute <code>FY</code> for <code>X</code>?</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="dt">C</span>(<span class="dt">FY</span>, <span class="dt">FY</span>) <span class="dt">≅</span> <span class="dt">D</span>(<span class="dt">Y</span>, <span class="dt">G</span>(<span class="dt">FY</span>))</code></pre>
</section><section class="slide level2">

<p>The only morphism we have that exists in all <code>C(FY, FY)</code> across all categories <code>C</code> would be the identity, so this is begging to be applied to the identity. Let's denote that <code>η = ϕ(id) :: Y -&gt; G(FY)</code>.</p>
<p>Similarly since <code>ϕ</code> is a bijection, lets apply it to <code>id ∈ D(GX, GX)</code> and keep that for later: <code>ε = ϕ^(-1)(id) :: F(G(X)) -&gt; X</code></p>
</section><section class="slide level2">

<p>Hmm, <code>F, G</code> are Functors... so:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">μ <span class="fu">=</span> <span class="dt">G</span>(ε)<span class="ot"> ::</span> <span class="dt">G</span>(<span class="dt">F</span>(<span class="dt">G</span>(<span class="dt">F</span>(<span class="dt">Y</span>)))) <span class="ot">-&gt;</span> <span class="dt">G</span>(<span class="dt">F</span>(<span class="dt">Y</span>)) <span class="co">-- I&#39;ve substituted FY for X</span>
δ <span class="fu">=</span> <span class="dt">F</span>(η)<span class="ot"> ::</span> <span class="dt">F</span>(<span class="dt">G</span>(<span class="dt">X</span>)) <span class="ot">-&gt;</span> <span class="dt">F</span>(<span class="dt">G</span>(<span class="dt">F</span>(<span class="dt">G</span>(<span class="dt">X</span>)))) <span class="co">-- I&#39;ve substituted GX for Y</span></code></pre>
</section><section id="recap" class="slide level2">
<h1>Recap</h1>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">η <span class="fu">=</span> ϕ(id)<span class="ot"> ::</span> <span class="dt">Y</span> <span class="ot">-&gt;</span> <span class="dt">G</span>(<span class="dt">FY</span>)
ε <span class="fu">=</span> ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(id)<span class="ot"> ::</span> <span class="dt">F</span>(<span class="dt">G</span>(<span class="dt">X</span>)) <span class="ot">-&gt;</span> <span class="dt">X</span>
μ <span class="fu">=</span> <span class="dt">G</span>(ε)<span class="ot"> ::</span> <span class="dt">G</span>(<span class="dt">F</span>(<span class="dt">G</span>(<span class="dt">F</span>(<span class="dt">Y</span>)))) <span class="ot">-&gt;</span> <span class="dt">G</span>(<span class="dt">F</span>(<span class="dt">Y</span>))
δ <span class="fu">=</span> <span class="dt">F</span>(η)<span class="ot"> ::</span> <span class="dt">F</span>(<span class="dt">G</span>(<span class="dt">X</span>)) <span class="ot">-&gt;</span> <span class="dt">F</span>(<span class="dt">G</span>(<span class="dt">F</span>(<span class="dt">G</span>(<span class="dt">X</span>))))</code></pre>
</section><section id="recap-1" class="slide level2">
<h1>Recap</h1>
<p>Save myself some writing, denote <code>M = G . F</code>, <code>W = F . G</code></p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">η <span class="fu">=</span> ϕ(id)<span class="ot"> ::</span> <span class="dt">Y</span> <span class="ot">-&gt;</span> <span class="dt">MY</span>        <span class="co">-- unit</span>
ε <span class="fu">=</span> ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(id)<span class="ot"> ::</span> <span class="dt">WX</span> <span class="ot">-&gt;</span> <span class="dt">X</span>   <span class="co">-- counit</span>
μ <span class="fu">=</span> <span class="dt">G</span>(ε)<span class="ot"> ::</span> <span class="dt">M</span>(<span class="dt">M</span>(<span class="dt">Y</span>)) <span class="ot">-&gt;</span> <span class="dt">MY</span>   <span class="co">-- join</span>
δ <span class="fu">=</span> <span class="dt">F</span>(η)<span class="ot"> ::</span> <span class="dt">WX</span> <span class="ot">-&gt;</span> <span class="dt">W</span>(<span class="dt">W</span>(<span class="dt">X</span>))   <span class="co">-- duplicate</span></code></pre>
</section><section id="left-identity" class="slide level2">
<h1>Left Identity</h1>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">μ <span class="fu">.</span> η <span class="fu">=</span> <span class="dt">G</span>(ε)<span class="fu">.</span>ϕ(id)
μ <span class="fu">.</span> η <span class="fu">=</span> <span class="dt">G</span>(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(id))<span class="fu">.</span>ϕ(id)
μ <span class="fu">.</span> η <span class="fu">=</span> ϕ(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(id) <span class="fu">.</span> id)  <span class="co">-- naturality</span>
μ <span class="fu">.</span> η <span class="fu">=</span> ϕ(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(id))
μ <span class="fu">.</span> η <span class="fu">=</span> id</code></pre>
</section><section id="right-identity" class="slide level2">
<h1>Right Identity</h1>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">μ <span class="fu">.</span> <span class="dt">GF</span>(η) <span class="fu">=</span> <span class="dt">G</span>(ε)<span class="fu">.</span><span class="dt">GF</span>(η)
μ <span class="fu">.</span> <span class="dt">GF</span>(η) <span class="fu">=</span> <span class="dt">G</span>(ε<span class="fu">.</span><span class="dt">F</span>(η))
μ <span class="fu">.</span> <span class="dt">GF</span>(η) <span class="fu">=</span> <span class="dt">G</span>(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(ϕ(ε<span class="fu">.</span><span class="dt">F</span>(η))))
μ <span class="fu">.</span> <span class="dt">GF</span>(η) <span class="fu">=</span> <span class="dt">G</span>(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(ϕ(ε)<span class="fu">.</span>η))
μ <span class="fu">.</span> <span class="dt">GF</span>(η) <span class="fu">=</span> <span class="dt">G</span>(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(ϕ(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(id))<span class="fu">.</span>η))
μ <span class="fu">.</span> <span class="dt">GF</span>(η) <span class="fu">=</span> <span class="dt">G</span>(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(id<span class="fu">.</span>η))
μ <span class="fu">.</span> <span class="dt">GF</span>(η) <span class="fu">=</span> <span class="dt">G</span>(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(η))
μ <span class="fu">.</span> <span class="dt">GF</span>(η) <span class="fu">=</span> <span class="dt">G</span>(id)
μ <span class="fu">.</span> <span class="dt">GF</span>(η) <span class="fu">=</span> id</code></pre>
</section><section id="associativity" class="slide level2">
<h1>Associativity</h1>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">μ <span class="fu">.</span> <span class="dt">GF</span>(μ) <span class="fu">=</span> <span class="dt">G</span>(ε)<span class="fu">.</span><span class="dt">GF</span>(μ)
μ <span class="fu">.</span> <span class="dt">GF</span>(μ) <span class="fu">=</span> <span class="dt">G</span>(ε<span class="fu">.</span><span class="dt">F</span>(μ))
μ <span class="fu">.</span> <span class="dt">GF</span>(μ) <span class="fu">=</span> <span class="dt">G</span>(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(ϕ(ε<span class="fu">.</span><span class="dt">F</span>(μ))))
μ <span class="fu">.</span> <span class="dt">GF</span>(μ) <span class="fu">=</span> <span class="dt">G</span>(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(ϕ(ε)<span class="fu">.</span>μ))
μ <span class="fu">.</span> <span class="dt">GF</span>(μ) <span class="fu">=</span> <span class="dt">G</span>(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(id<span class="fu">.</span>μ))
μ <span class="fu">.</span> <span class="dt">GF</span>(μ) <span class="fu">=</span> <span class="dt">G</span>(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(μ))
μ <span class="fu">.</span> <span class="dt">GF</span>(μ) <span class="fu">=</span> <span class="dt">G</span>(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(<span class="dt">G</span>(ε)))
μ <span class="fu">.</span> <span class="dt">GF</span>(μ) <span class="fu">=</span> <span class="dt">G</span>(ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(<span class="dt">G</span>(ε)<span class="fu">.</span>id))
μ <span class="fu">.</span> <span class="dt">GF</span>(μ) <span class="fu">=</span> <span class="dt">G</span>(ε<span class="fu">.</span>ϕ<span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>)(id))
μ <span class="fu">.</span> <span class="dt">GF</span>(μ) <span class="fu">=</span> <span class="dt">G</span>(ε<span class="fu">.</span>ε)
μ <span class="fu">.</span> <span class="dt">GF</span>(μ) <span class="fu">=</span> <span class="dt">G</span>(ε)<span class="fu">.</span><span class="dt">G</span>(ε)
μ <span class="fu">.</span> <span class="dt">GF</span>(μ) <span class="fu">=</span> μ <span class="fu">.</span> μ</code></pre>
</section><section id="so-m-is-a-monad" class="slide level2">
<h1>So M is a monad</h1>
</section><section id="w-is-a-comonad" class="slide level2">
<h1>W is a comonad</h1>
<p>Err... an &quot;Exercise&quot;?</p>
</section><section id="converse" class="slide level2">
<h1>Converse?</h1>
<p>Can all (co)monads be broken up into adjoint functor pairs?</p>
<p>Yes, there are at least two such pairs that exist for all monads (and comonads). They are kind of trivial constructions though, and involve &quot;exotic&quot; categories, so they are less useful to the Scala and Haskell programmers (Where you are stuck in <code>Hask</code> or whatever the Scala equivalent is):</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Kleisli_category">The Kleisli Category</a></li>
<li><a href="https://en.wikipedia.org/wiki/Eilenberg%E2%80%93Moore_algebra">Eilenberg-Moore algebras</a></li>
</ul>
</section><section id="universal-property" class="slide level2">
<h1>Universal Property</h1>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">h ::</span> <span class="dt">Y</span> <span class="ot">-&gt;</span> <span class="dt">GZ</span>
h <span class="fu">=</span> ϕ(k)        <span class="co">-- k = ϕ^(-1)(h) :: FY -&gt; Z</span>
h <span class="fu">=</span> ϕ(k <span class="fu">.</span> id)
h <span class="fu">=</span> <span class="dt">Gk</span> <span class="fu">.</span> ϕ(id)  <span class="co">-- naturality</span>
h <span class="fu">=</span> <span class="dt">Gk</span> <span class="fu">.</span> η</code></pre>
</section><section id="uniqueness" class="slide level2">
<h1>Uniqueness</h1>
<p>So all <code>h :: Y -&gt; GZ</code> can be factorised. But is <code>k</code> unique?</p>
<p>assume it isn't,</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">k ::</span> <span class="dt">FY</span> <span class="ot">-&gt;</span> <span class="dt">Z</span>
<span class="ot">k&#39; ::</span> <span class="dt">FY</span> <span class="ot">-&gt;</span> <span class="dt">Z</span>
<span class="co">-- assume k, k&#39; &quot;distinct&quot;</span>
(<span class="dv">1</span>) h <span class="fu">=</span> <span class="dt">Gk</span> <span class="fu">.</span> η and (<span class="dv">2</span>) h <span class="fu">=</span> <span class="dt">Gk&#39;</span> <span class="fu">.</span> η
(<span class="dv">1</span>) <span class="ot">-&gt;</span> h <span class="fu">=</span> ϕ(k), and (<span class="dv">2</span>) <span class="ot">-&gt;</span> h <span class="fu">=</span> ϕ(k&#39;) <span class="co">-- reverse the existence proof</span>
<span class="co">-- But ϕ is a bijection, so k = k&#39;, which contradicts the assumption</span></code></pre>
</section><section id="universal-property-1" class="slide level2">
<h1>Universal Property</h1>
<figure>
<img src="./assets/unit-universal-prop.png" alt="general unit initial property" /><figcaption>general unit initial property</figcaption>
</figure>
</section><section class="slide level2">

<figure>
<img src="./assets/monad-universal-prop.png" alt="slightly specialised unit initial property" /><figcaption>slightly specialised unit initial property</figcaption>
</figure>
</section><section id="context" class="slide level2">
<h1>Context?</h1>
<ul>
<li>The functor <code>F</code> represents the construction upon <code>Y</code> that represents this &quot;context&quot; thing that everyone talks about.</li>
<li>As all operations of the form <code>Y -&gt; MY'</code> can be reduced to functions of type <code>FY -&gt; FY'</code>.</li>
<li>The functor <code>G</code> represents the reverse direction, it represents the &quot;problem&quot; that you &quot;want something in <code>FY</code> but lack the components to make the construction&quot;</li>
</ul>
</section><section id="deferred-problems" class="slide level2">
<h1>Deferred Problems</h1>
<p>Monads lets us defer the construction problem. We can effectively pretend the problem doesn't exist.</p>
<ul>
<li>We can use <code>η</code> to get us into <code>G(FY)</code></li>
<li>Then <code>fmap</code> so that we can work inside <code>D(FY, FY')</code>, helping us pretend the problem doesn't exist.</li>
<li><code>μ</code> can let us &quot;eliminate&quot; the problem inside this fantasy land where it doesn't exist</li>
<li>we can ignore the problem of <code>GX -&gt; X</code> until such a time as we have what we need.</li>
</ul>
<p>This is why monads are so useful...</p>
</section><section id="deferred-solutions" class="slide level2">
<h1>Deferred Solutions</h1>
<p>Comonads are the opposite:</p>
<ul>
<li>We have objects of <code>F(GX)</code>, we have a constructed solution around a value waiting for the stuff in <code>F</code>, just waiting to be unrolled with <code>ε</code>. At any time.</li>
</ul>
<p>Applications for this exist, but they seem harder to imagine...</p>
</section><section class="slide level2">

<p>Monads let us abstract away problems, comonads let us hold solutions for ransom.</p>
</section><section id="monad-transformers" class="slide level2">
<h1>Monad Transformers</h1>
<p>So now can we structurally decompose monads to embed others?</p>
<p>For <code>F: D -&gt; C</code> and <code>G: C -&gt; D</code> functors between locally small categories <code>C</code> and <code>D</code>, if we have a monad <code>M: C -&gt; C</code> is <code>G . M . F</code> a monad?</p>
<p>Yes it is (Exercise)</p>
</section></section>
<section><section id="examples-1" class="titleslide slide level1"><h1>Examples</h1></section><section id="state-monad" class="slide level2">
<h1>State Monad</h1>
<p>This is the famous one, its pretty much the only one that can be broken up into two functors <code>Hask -&gt; Hask</code></p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">F</span> s a <span class="fu">=</span> (a, s)
<span class="kw">type</span> <span class="dt">G</span> s a <span class="fu">=</span> s <span class="ot">-&gt;</span> a
ϕ <span class="fu">=</span> curry</code></pre>
</section><section class="slide level2">

<pre><code>curry :: ((a, b) -&gt; c) -&gt; a -&gt; b -&gt; c
curry id :: a -&gt; b -&gt; (a, b)            -- unit
uncurry id :: (b -&gt; c, b) -&gt; c          -- counit
fmap (uncurry id) :: Functor f =&gt; f (b1 -&gt; b, b1) -&gt; f b    -- join</code></pre>
</section><section id="continuation-monad" class="slide level2">
<h1>Continuation Monad</h1>
<p>This is a unique example where the Functor leaves <code>Hask</code> and passes through <code>Hask^(op)</code> before coming back, it is adjoint to itself.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">C</span> r a <span class="fu">=</span> a <span class="ot">-&gt;</span> r
<span class="kw">type</span> <span class="dt">Cont</span> a <span class="fu">=</span> forall r<span class="fu">.</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="fu">~</span> forall r<span class="fu">.</span> (<span class="dt">C</span> r (<span class="dt">C</span> r a))</code></pre>
</section><section class="slide level2">

<p>For <code>ϕ</code> we want a function:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="co">--  Hask ^(op)      |   Hask</span>
ϕ<span class="ot"> ::</span> (<span class="dt">C</span> r a <span class="fu">~&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">C</span> r b)
ϕ<span class="ot"> ::</span> (<span class="dt">C</span> r a <span class="ot">&lt;-</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">C</span> r b)
ϕ<span class="ot"> ::</span> (b <span class="ot">-&gt;</span> <span class="dt">C</span> r a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">C</span> r b)
ϕ<span class="ot"> ::</span> (b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r)) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">C</span> r b)
ϕ<span class="ot"> ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> r))
ϕ<span class="ot"> ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r)
ϕ <span class="fu">=</span> flip</code></pre>
</section><section id="free-constructions" class="slide level2">
<h1>Free Constructions</h1>
<pre><code>F ~ Free Construction
U ~ Forgetful functor
ϕ :: (FY -&gt; X) &lt;-&gt; (Y -&gt; GZ)</code></pre>
</section></section>
<section><section id="references" class="titleslide slide level1"><h1>References</h1></section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'sky', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
  </body>
</html>
